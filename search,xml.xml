<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0</title>
    <url>/2019/03/21/0/</url>
    <content><![CDATA[<p>TEST.0v0</p>
]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>19-08-20</title>
    <url>/2019/08/20/19-08-20/</url>
    <content><![CDATA[<p>深夜，雨停。<br>黑暗的房间中只有电脑屏幕的光。</p>
<p>正在剪辑视频的我被屏幕前方飞来飞去的苍蝇蚊虫打乱了兴致，无论我如何驱逐它们，它们都像训练有素的哨兵巡逻一般在屏幕前来回踱步。我稍稍有些恼怒，抓起一张卫生纸动了杀心，但是飞虫们似乎早就看穿了我的行动，上一秒还在屏幕上搓手的苍蝇，在下一秒我手掌按下的风压还未接触到它们的躯壳之前便早早飞离我的攻击范围，并在安全地点稍做了停留后又飞回屏幕上，好像视危险于无物，不将我放在眼中一样。我接连出击但也只能落得下风，心情也越发急躁。<br>突然间，我看着屏幕上的虫子，不知怎得平静了下来。我慢慢起身，将房间的大灯打开，本没有多刺眼的光在上一瞬还是黑暗的卧室中显得是那么的明亮。虫子们如获至宝，离开了我的屏幕，朝着那救世般的光明飞去。我松了口气，坐回我的电脑前继续我的剪辑。</p>
<p>这世间，谁又不是虫子呢？<br>                                      -19-08-20 1：05</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>C#嵌套类</title>
    <url>/2021/11/26/Csharp%E5%B5%8C%E5%A5%97%E7%B1%BB/</url>
    <content><![CDATA[<font size=5 face="黑体">1.基本概念</font>

<p> 【与Java中同名概念类似】<br>  <font size=3 face="黑体">嵌套类(Nested class)</font>：类中定义的类<br>   （1）静态嵌套类（使用较少，不概述）<br>   （2）非静态嵌套类（也称内部类）</p>
  <font size=3 face="黑体">内部类(Inner class)</font>：<br>   （1）成员内部类(Member inner class)：类中直接定义的类<br>   （2）局部内部类(Local inner class)：类中方法里定义的类<br>   （3）匿名内部类(Anonymous inner class)<br><br><font size=5 face="黑体">2.访问权限</font>

<p> （1）外部类只能够访问嵌套类中修饰符为public、internal的成员<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Set_Pet</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//编译正确</span></span><br><span class="line">        Cat._high = <span class="number">123</span>;</span><br><span class="line">        Cat._age = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//编译失败</span></span><br><span class="line">        <span class="comment">//Cat._name = &quot;Tom&quot;;</span></span><br><span class="line">        <span class="comment">//Cat._sex = &quot;male&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> _name;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">string</span> _sex;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">int</span> _age;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> _high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> （2）嵌套类访问外部类成员不受访问修饰符限制</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Set_Pet</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Cat.Set_Cat(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Set_Cat</span>(<span class="params">Pet a</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _age = <span class="number">3</span>;        <span class="comment">//静态成员</span></span><br><span class="line">            a._name = <span class="string">&quot;Tom&quot;</span>; <span class="comment">//实例成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font size=5 face="黑体">3.嵌套类的作用</font><br><font size=3 face="黑体">Java嵌套类百科：</font><br><pre><code>使用嵌套类的主要理由是：<br><br>1.它是一种只对一个地方使用的类进行逻辑分组的方法：<br>    如果一个类只对另一个类有用，那么将其嵌入到该类中并使这两个类保持在一起是合乎逻辑的。嵌套这样的“助手类（Helper Class）”使它们所在的包更为精简。<br><br>2.它增强了封装性：<br>    考虑两个顶层类（Top-Level Class），A 和 B，当 B 需要访问 A 中被声明为 private 的成员时，可将 B 嵌入 A 中，这样 B 就可以访问 A 中的私有成员了。此外，B 本身也可以对外界隐藏起来。<br><br>3.它使代码更具可读性和可维护性：<br>    在顶层类中嵌套小类，会使代码更接近其使用的位置。</code></pre><br> 在C#中除Java中嵌套类的几个用途外，由于C#语言特性，<span id="inline-blue">嵌套类在外部类被调用时才会被实例化</span>，所以也可用于特定功能实现，如后文中提到的延迟加载线程安全的无锁单例类。<br><br><br><font size=5 face="黑体">4.嵌套类的使用</font>

<p>（1）嵌套类访问外部类实例的方法、字段、属性时候。一般在采取构造函数输入外部类</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params">Pet a</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            a._name = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> （2）继承类的嵌套类可以继承父类中的嵌套类</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SayMyName</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;猫&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommonPet</span> : <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">RagdollCat</span> : <span class="title">Cat</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SayMyName</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;布偶猫&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>p.s.：因为CommonPet继承于Pet ，因此RagdollCat可以继承Cat类，从而获取继承父嵌套类的机会。<br>但是Cat必须是可继承类且可访问的（非private 、sealed 、static）。嵌套类可随意访问外部类的成员，而外部类访问嵌套类需要遵守访问修饰符。<br>所以这样来看嵌套类是对外部类的补充，从程序结构看，嵌套类在逻辑上更接近使用类。可以更有效地表示类与类间的紧密程度，为类的管理提供除命名空间外的另一种方法。所以通过嵌套类可以获取更好的封装性，增加外部类的可维护性和可读性。（嵌套类百科中嵌套类作用第2、3点）</p>
<p>（3）延迟加载单例模式（Fully lazy singleton）<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Pet Intance &#123; <span class="keyword">get</span> =&gt; Cat._intance; &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">static</span> Pet _intance = <span class="keyword">new</span> Pet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>p.s.：嵌套类的静态构造函数不随外部类的实例化而调用。因此可以有效地避免实例化外部类时嵌套类的初始化时间，当需要使用嵌套类时，嵌套类才开始实例化，也叫懒加载。详见<a href="/2021/11/26/Csharp单例模式的多种实现">C#单例模式的多种实现</a></p>
<p>（4）反射内嵌类需要使用”+”而不是常用的”.” </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">PetClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <font face="黑体">主函数中执行下列语句：</font></p>
<pre><code>object o1 = Type.GetType("PetClass.Pet+Cat", true);
//成功</code></pre>
<pre><code>object o2 = Type.GetType("PetClass.Pet.Cat", true);
//失败 抛出System.TypeLoadException异常
</code></pre>

]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C#单例模式的多种实现</title>
    <url>/2021/11/26/Csharp%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<font size=5 face="黑体">1.基本概念</font>



]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Job System简介</title>
    <url>/2021/12/02/Job%20System%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><a href="https://docs.unity3d.com/Manual/JobSystem.html">Job System官方手册</a>上对于Job System的描述是:</p>
<p><pre>The Unity C# Job System lets you write simple and safe multithreaded code that interacts with the Unity Engine for enhanced game performance.</p>
<p>You can use the C# Job System with the Unity Entity Component System (ECS), which is an architecture that makes it simple to create efficient machine code for all platforms.</pre><br>简单来说就是Unity自己封好的一个更为安全的多线程解决方案，建议和ECS搭配使用。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>DOTS</tag>
        <tag>Job System</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>HighlightTest</title>
    <url>/2021/11/16/HighlightTest/</url>
    <content><![CDATA[<p><span id="inline-blue"> 蓝色背景高亮 </span><br><span id="inline-purple"> 紫色背景高亮 </span><br><span id="inline-yellow"> 黄色背景高亮 </span><br><span id="inline-green"> 绿色背景高亮 </span><br>普通代码块<pre><code>——–Normal-Code——–<br>Test1<br>    Test2<br>        Test3<br>——–CodeEnd——–<br></code></pre><br>c#代码块</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsRandomProbability</span>(<span class="params"><span class="built_in">int</span> numerator, <span class="built_in">int</span> denominator</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> random = UnityEngine.Random.Range(<span class="number">0</span>, denominator);</span><br><span class="line">    <span class="keyword">if</span> (random &lt; numerator)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java代码块<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity DOTS</title>
    <url>/2021/12/02/Unity%20DOTS/</url>
    <content><![CDATA[<p>DOTS 全称 Data-Oriented-Tech-Stack：直译为“面向数据技术栈”，官方翻译是“多线程式数据导向型技术堆栈”<br>它是一个Unity推出的项目开发的完整解决方案，由三部分组成：</p>
<p><pre><code>Job System（任务系统）：编写多线程代码<br>ECS（Entity Component System 实体组件系统）：编写高性能代码<br>Burst Compliler（Burst编译器）：编译生成高性能代码<br></code></pre><br>Job System和Burst使得在某些特定场景里运行性能能够提升几千倍，但DOTS并不是一个单纯的解决性能问题的解决方案，其中的ECS解决了Unity一些长期的架构问题，相较于传统的GameObject来说ECS具有得天独厚的优势，当然也有缺憾，这些在相对应的文章里再进行详述。</p>
<p>DOTS现在在实际应用和推广上比较困难，主要因为本身还不是特别成熟，更新迭代速度非常快。并且本身的面向数据的特性也使得开发阶段的工作更为细碎漫长，所以一般是将其三个部分分开并与传统Unity框架开发混合起来使用。</p>
<p>如何使用DOTS？</p>
<p>首先检查Unity版本，一般建议2019以上；确保工程里的Packages中有<pre>Burst<br>Entities<br>Jobs<br>Hybrid Renderer（DOTS的渲染相关）<br>Unity Physics(DOTS的高性能物理组件)<br>Collections（提供一些原生集合）<br>Mathematics（可用于Burst编译的数学库）</pre><br>若没有则<code>打开菜单栏-window-&gt;package manager，右侧的Advanced下拉切换为show preview package，找到上述包并安装。</code>如果是2020或更高版本可能不能在package manager里查看预览包，那么可以选择<code>在项目根目录下找到Packages下的manifest.json文件，打开并在dependencies依赖包目录中添加上述对应版本的upm包</code>，或者<code>打开package manager，在左上角＋号图标选择Add package from git URL，输入包名手动添加。</code></p>
<p>接着介绍ECS和Job System：<br><a href="/tags/">ECS</a><br><a href="/tags/Job-System/">Job System</a></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>DOTS</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>中秋</title>
    <url>/2019/09/13/%E4%B8%AD%E7%A7%8B/</url>
    <content><![CDATA[<p>一点寒意刺骨，两三昏暗街灯，密密麻麻雨点撕裂黑空携着冷冽一同贯穿着我的神经。啪嗒啪嗒，本应寂寞空寥的夜反被这寒冷的雨带得躁动了起来，可能正因这无序的雨的轻吟，这夜也显得不那么孤独。屋内热闹屋外喧嚣，十五不见月，倒也无妨。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>只有秒表和游标卡尺不估读</title>
    <url>/2019/10/12/%E5%8F%AA%E6%9C%89%E7%A7%92%E8%A1%A8%E5%92%8C%E6%B8%B8%E6%A0%87%E5%8D%A1%E5%B0%BA%E4%B8%8D%E4%BC%B0%E8%AF%BB/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><br>是炉中带火的余烬，雪中枯梅的寒芯<br>是濒死时闪耀的天体，热寂前躁动的微粒<br><br>是拖曳着寂寥于大气殆尽的流星<br>是裹挟着幽怨在彼岸游荡的幽灵<br><br>是六千五百万年前唯一幸存的蛇颈龙，<br>在浓雾中追寻着那伪装成同伴的灯塔号角<br>是辗转千里在大西洋郁郁而终的蓝鲸，<br>在大海深处轻吟着52赫兹镇魂曲化为孤岛<br>是受统一场理论束缚的爱因斯坦<br>是被平方根囚禁的根号三<br>是数着梅花的李寻欢<br>是背离光的暗<br>不愿变成旺火的柴薪<br>也不羡慕暖春的林荫<br>像中微子穿过实体，飞鸟划过天际<br>不着痕迹地活着<br></blockquote>

]]></content>
      <categories>
        <category>短诗</category>
      </categories>
  </entry>
  <entry>
    <title>交流</title>
    <url>/2019/05/10/%E4%BA%A4%E6%B5%81/</url>
    <content><![CDATA[<p>我是什么时候这么畏惧交流的，愈发的自闭，封闭体系中的熵增不可逆，这么简单的道理我是早就明白的呀。交流，多交流，目前为止失去的都是交流上出了问题。交流。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>容器</title>
    <url>/2019/12/02/%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>看了福山雅治主演的第三度嫌疑人，许多困扰着我的问题我有了更深的理解。有理性的人类会将他们做出的行为赋予意义，将这些行为举动理性化，人们经常会做出一些难以理解的行为，但又主观性的给予其逻辑性，如第三度嫌疑人中的重盛一直在找凶手的杀人动机，一厢情愿地认为凶手是为救人而去杀人的，可是杀手也许不需要理由，所有的假设都只停留在假设，所有的真相都是片面主观的，杀手三隅只是一个容器，人们自私地往里面灌注自己的情感，自私地赋予他行凶的动机，但就如片中所说像盲人摸象一样，没有人能看到真理的模样。</p>
<p>我们或许比三隅情感丰富，比三隅善良，不会去杀人更不会去一遍遍地欺骗着想要帮助自己的人，但是我们每个人都戴着一顶面具，一顶名为理客的面具。我们自私地为我们的每个行为每个举动解释，带着理性的帽子，自圆其说般地活在这个以谎言为食的世界。人格是时间打磨而成的，当一个人不断在理性的环境下生活，接受理性的教育，他的人格也将建立在理性的框架之下，也会理性地为自己的种种行为理性地“开脱”。其中不乏真实地情感，但是人生就如同语文阅读题一样，其中也存在过度解读的成分，而人格不是非黑即白的，它经过时间的打磨，随着年龄的增长变得复杂而立体，人们总是试图去分析去比较它，可是这往往比人们想的要难一些。</p>
<p>我曾经也经常性的冒出一些很可怕不受控制的想法，最开始的时候我并没有想过要去约束它，但是后面它开始变得有些不受控制，思想是不受约束的，我开始害怕，它是无端由地出现，让我怀疑自己的人格是否堕落了。所幸人格实质上并没有好坏的分别，所谓高尚与否只是人们一厢情愿给它的意义，它只决定于你的三观，也就是说它是主观所决定的。</p>
<p>每个人都不过是「空的容器」，你是谁，你在想什么，都取决于别人想要看到的是什么。</p>
<p>我们都是容器。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>无题</title>
    <url>/2019/05/09/%E6%97%A0%E9%A2%98/</url>
    <content><![CDATA[<p>两天阴雨之后是温和不强烈的阳光，无声洒在我的后颈上像是按摩一般摩擦着我的皮肤。我不由得想在路上停住慢慢享受这般待遇，但是，在路上的人哪有理由不行走呢？我停不下来，只得一头扎进阴影之中，后颈上按摩师的手猛地抬离，随之我的影子也便融进那有界无望的黑暗中。我很害怕，尽管已是熟识的老朋友，但是现在我却很怕黑暗跟孤独，也许是只有站在阳光下我在看得见我的影子，我才能知道我可能与常人无异，但那必须是温和的阳光，若是强光，我便又失了影子。不止是心理上精神上的，我的感官带给我的感觉也在慢慢消退，可能终有一日我会变成行尸走肉，但至少现在我还没有勇气去违背这个进程。<br>也许我有。这是个愚蠢的想法，但是我觉得假如我能反抗，我就能找到存在的意义。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>误差</title>
    <url>/2019/03/23/%E8%AF%AF%E5%B7%AE/</url>
    <content><![CDATA[<p>人总是会做很多自己也不理解的，不知道为什么要去做甚至是无意义的事，而经常性地，人们会去分析做这些事的原因并赋予其合理性，也就是将混沌变为逻辑。<br>我亲历过很多与客观事实规律不合的事，举在我身上的例子来说，常年贴脸熬夜玩手机眼睛视力好像也没有变化，经常性暴饮暴食体重依旧。大概是真实世界误差太过严重，让我选择忽略了那些遵循规律的事实而选择暂时归从混沌。但是许多事确实也不是我所认知的客观规律能够解释的，比如人的心情想法，许多时候我会忍不住去想坏到极致的事，这种现象在曾经更为严重。虽然我崇尚绝对的理性和逻辑性，但本身存在于一个误差中的世界，让我的局限性无法遮掩，这让我难过。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
